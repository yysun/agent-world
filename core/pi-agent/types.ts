/**
 * Type Adapters for Pi-AI Integration
 * 
 * Converts between Agent-World types and pi-ai types.
 * 
 * Key Differences:
 * - Agent-World: content is string, tool_calls is array
 * - pi-ai: content is array of TextContent | ToolCall blocks
 * 
 * - Agent-World: 'tool' role with tool_call_id
 * - pi-ai: 'toolResult' role with toolCallId, toolName, isError
 * 
 * Features:
 * - Bidirectional message conversion
 * - Provider name mapping (Azure â†’ OpenAI, etc.)
 * - Tool call format adaptation
 */

import type { ChatMessage, Agent } from '../types.js';
import type { Message, UserMessage, AssistantMessage, ToolResultMessage, Context } from '@mariozechner/pi-ai';

/**
 * Convert Agent-World ChatMessage to pi-ai Message
 */
export function adaptToPiAiMessage(msg: ChatMessage): Message | null {
  const timestamp = msg.createdAt?.getTime() || Date.now();

  switch (msg.role) {
    case 'user':
    case 'system': {
      // pi-ai doesn't have a system role, system prompts go in Context.systemPrompt
      // For now, treat system messages as user messages
      return {
        role: 'user',
        content: msg.content,
        timestamp,
      } as UserMessage;
    }

    case 'assistant': {
      // pi-ai expects content to be an array of blocks
      const content: AssistantMessage['content'] = [];

      // Add text content
      if (msg.content) {
        content.push({
          type: 'text',
          text: msg.content,
        });
      }

      // Add tool calls
      if (msg.tool_calls && msg.tool_calls.length > 0) {
        for (const tc of msg.tool_calls) {
          content.push({
            type: 'toolCall',
            id: tc.id,
            name: tc.function.name,
            arguments: JSON.parse(tc.function.arguments),
          });
        }
      }

      // pi-ai AssistantMessage requires api, provider, model, usage, stopReason
      // We don't have these for historical messages, so we skip them
      // This means we can't directly convert old assistant messages to pi-ai format
      // Instead, we'll need to filter them out or reconstruct minimal info
      return null; // Skip for now - pi-ai will generate new assistant messages
    }

    case 'tool': {
      // Convert tool response to pi-ai format
      if (!msg.tool_call_id) {
        return null; // Invalid tool message
      }

      return {
        role: 'toolResult',
        toolCallId: msg.tool_call_id,
        toolName: extractToolNameFromMessage(msg),
        content: [{
          type: 'text',
          text: msg.content,
        }],
        isError: false, // Agent-World doesn't track this explicitly
        timestamp,
      } as ToolResultMessage;
    }

    default:
      return null;
  }
}

/**
 * Extract tool name from tool message
 * In Agent-World, tool messages might not have explicit tool name
 */
function extractToolNameFromMessage(msg: ChatMessage): string {
  // Try to extract from content or use a default
  return 'unknown';
}

/**
 * Convert pi-ai AssistantMessage to Agent-World ChatMessage
 */
export function adaptFromPiAiMessage(msg: AssistantMessage, agentId: string): ChatMessage {
  let content = '';
  const tool_calls: ChatMessage['tool_calls'] = [];

  for (const block of msg.content) {
    if (block.type === 'text') {
      content += block.text;
    } else if (block.type === 'toolCall') {
      tool_calls.push({
        id: block.id,
        type: 'function',
        function: {
          name: block.name,
          arguments: JSON.stringify(block.arguments),
        },
      });
    }
    // Skip thinking blocks for now
  }

  return {
    role: 'assistant',
    content,
    tool_calls: tool_calls.length > 0 ? tool_calls : undefined,
    createdAt: new Date(msg.timestamp),
  };
}

/**
 * Prepare context for pi-ai from Agent-World messages
 * 
 * Note: pi-ai Context includes systemPrompt separately, not in messages
 */
export function adaptToPiAiContext(
  agent: Agent,
  messages: ChatMessage[]
): Context {
  // Extract system prompt from first system message if present, otherwise use agent's
  let systemPrompt = agent.systemPrompt || '';
  let foundSystemMessage = false;
  const filteredMessages: Message[] = [];

  for (const msg of messages) {
    if (msg.role === 'system') {
      // Use first system message as systemPrompt if not already found
      if (msg.content && !foundSystemMessage) {
        systemPrompt = msg.content;
        foundSystemMessage = true;
      }
      // Skip system messages - they're handled via Context.systemPrompt
      continue;
    }

    // Only convert user and tool messages for history
    // assistant messages will be generated by pi-ai
    const adapted = adaptToPiAiMessage(msg);
    if (adapted) {
      filteredMessages.push(adapted);
    }
  }

  return {
    systemPrompt,
    messages: filteredMessages,
  };
}

/**
 * Map Agent-World provider names to pi-ai provider names
 */
export function mapProviderName(provider: string): string {
  const mapping: Record<string, string> = {
    'openai': 'openai',
    'anthropic': 'anthropic',
    'google': 'google',
    'azure': 'azure-openai-responses',
    'ollama': 'openai', // Ollama uses OpenAI-compatible API
    'openai-compatible': 'openai',
    'xai': 'xai',
  };
  
  return mapping[provider] || provider;
}

/**
 * Get model identifier for pi-ai
 * Some providers need different model names
 */
export function getModelIdentifier(provider: string, model: string): string {
  // Most providers use model name as-is
  // Special cases can be handled here
  return model;
}
