<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Storage Module Browser Test</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f8f9fa;
    }

    .container {
      background: white;
      border-radius: 8px;
      padding: 24px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .test-section {
      margin: 20px 0;
      padding: 16px;
      border: 1px solid #e9ecef;
      border-radius: 6px;
    }

    .test-section h3 {
      margin: 0 0 12px 0;
      color: #495057;
    }

    .status {
      padding: 8px 12px;
      border-radius: 4px;
      margin: 8px 0;
      font-weight: 500;
    }

    .status.success {
      background: #d4edda;
      color: #155724;
    }

    .status.error {
      background: #f8d7da;
      color: #721c24;
    }

    .status.info {
      background: #d1ecf1;
      color: #0c5460;
    }

    .controls {
      margin: 12px 0;
    }

    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin: 4px;
    }

    button:hover {
      background: #0056b3;
    }

    button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }

    pre {
      background: #f8f9fa;
      padding: 12px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 14px;
    }

    .stats {
      background: #f8f9fa;
      padding: 12px;
      border-radius: 4px;
      margin: 8px 0;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>üóÉÔ∏è Storage Module Browser Test</h1>
    <p>This page tests the unified storage module functionality in a real browser environment.</p>
    <div class="test-section">
      <h3>Phase 3.2 Integration Tests</h3>
      <div id="integration-status" class="status info">Ready to run comprehensive integration tests</div>
      <div class="controls">
        <button onclick="runPhase32Tests()">Run Phase 3.2 Integration Tests</button>
        <button onclick="generateIntegrationReport()">Generate Test Report</button>
      </div>
      <div id="integration-results"></div>
    </div>

    <div class="test-section">
      <h3>Storage Initialization</h3>
      <div id="init-status" class="status info">Ready to test</div>
      <div class="controls">
        <button onclick="initializeStorage()">Initialize Storage</button>
        <button onclick="getStorageStats()">Get Stats</button>
      </div>
      <div id="storage-stats" class="stats" style="display: none;"></div>
    </div>

    <div class="test-section">
      <h3>World Storage Operations</h3>
      <div id="world-status" class="status info">Ready to test</div>
      <div class="controls">
        <button onclick="testWorldOperations()">Test World CRUD</button>
        <button onclick="testBulkOperations()">Test Bulk Operations</button>
        <button onclick="clearAllWorlds()">Clear All Worlds</button>
      </div>
      <div id="world-results"></div>
    </div>

    <div class="test-section">
      <h3>Storage Fallback Testing</h3>
      <div id="fallback-status" class="status info">Ready to test</div>
      <div class="controls">
        <button onclick="testFallbackChain()">Test Fallback Chain</button>
        <button onclick="simulateErrors()">Simulate Storage Errors</button>
      </div>
      <div id="fallback-results"></div>
    </div>

    <div class="test-section">
      <h3>Performance Testing</h3>
      <div id="perf-status" class="status info">Ready to test</div>
      <div class="controls">
        <button onclick="testPerformance()">Run Performance Test</button>
        <button onclick="testLargeData()">Test Large Data Storage</button>
      </div>
      <div id="perf-results"></div>
    </div>

    <div class="test-section">
      <h3>Debug Information</h3>
      <div class="controls">
        <button onclick="dumpDebugInfo()">Dump Debug Info</button>
        <button onclick="clearLogs()">Clear Logs</button>
      </div>
      <pre id="debug-logs"></pre>
    </div>
  </div>
  <script type="module">
    // Import storage module
    import { storage, STORES, STORAGE_LEVELS, UnifiedStorage } from './storage.js';

    // Import integration tests
    import './storage-integration-test.js';

    // Make available globally for onclick handlers
    window.storage = storage;
    window.STORES = STORES;
    window.STORAGE_LEVELS = STORAGE_LEVELS;
    window.UnifiedStorage = UnifiedStorage;

    // Logging utility
    const log = (message, type = 'info') => {
      const timestamp = new Date().toLocaleTimeString();
      const logElement = document.getElementById('debug-logs');
      const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}\n`;
      logElement.textContent += logEntry;
      console.log(logEntry);
    };

    // Initialize storage
    window.initializeStorage = async () => {
      const statusEl = document.getElementById('init-status');
      try {
        statusEl.textContent = 'Initializing...';
        statusEl.className = 'status info';

        await storage.init();
        const level = storage.getStorageLevel();

        statusEl.textContent = `‚úÖ Storage initialized at level: ${level}`;
        statusEl.className = 'status success';
        log(`Storage initialized successfully at level: ${level}`, 'success');

        // Auto-load stats
        await getStorageStats();
      } catch (error) {
        statusEl.textContent = `‚ùå Initialization failed: ${error.message}`;
        statusEl.className = 'status error';
        log(`Storage initialization failed: ${error.message}`, 'error');
      }
    };

    // Get storage statistics
    window.getStorageStats = async () => {
      try {
        const stats = await storage.getStats();
        const statsEl = document.getElementById('storage-stats');
        statsEl.innerHTML = `
                    <h4>Storage Statistics</h4>
                    <p><strong>Level:</strong> ${stats.level}</p>
                    <p><strong>Stores:</strong></p>
                    <ul>
                        ${Object.entries(stats.stores).map(([store, info]) =>
          `<li>${store}: ${info.itemCount} items</li>`
        ).join('')}
                    </ul>
                `;
        statsEl.style.display = 'block';
        log(`Storage stats retrieved: ${JSON.stringify(stats)}`, 'info');
      } catch (error) {
        log(`Failed to get storage stats: ${error.message}`, 'error');
      }
    };

    // Test world CRUD operations
    window.testWorldOperations = async () => {
      const statusEl = document.getElementById('world-status');
      const resultsEl = document.getElementById('world-results');

      try {
        statusEl.textContent = 'Testing world operations...';
        statusEl.className = 'status info';
        resultsEl.innerHTML = '';

        const testWorld = {
          id: 'test-world-1',
          name: 'Test World',
          description: 'A test world for storage validation',
          turnLimit: 10,
          agents: [
            { id: 'agent1', name: 'Test Agent', role: 'assistant' }
          ],
          created: Date.now()
        };

        // Test CREATE
        log('Testing world creation...', 'info');
        const created = await storage.setItem(STORES.worlds, testWorld.id, testWorld);
        if (!created) throw new Error('World creation failed');

        // Test READ
        log('Testing world retrieval...', 'info');
        const retrieved = await storage.getItem(STORES.worlds, testWorld.id);
        if (!retrieved || retrieved.id !== testWorld.id) {
          throw new Error('World retrieval failed');
        }

        // Test UPDATE
        log('Testing world update...', 'info');
        const updatedWorld = { ...testWorld, name: 'Updated Test World' };
        await storage.setItem(STORES.worlds, testWorld.id, updatedWorld);
        const updated = await storage.getItem(STORES.worlds, testWorld.id);
        if (updated.name !== 'Updated Test World') {
          throw new Error('World update failed');
        }

        // Test LIST
        log('Testing world listing...', 'info');
        const keys = await storage.listKeys(STORES.worlds);
        if (!keys.includes(testWorld.id)) {
          throw new Error('World listing failed');
        }

        // Test DELETE
        log('Testing world deletion...', 'info');
        await storage.removeItem(STORES.worlds, testWorld.id);
        const deleted = await storage.getItem(STORES.worlds, testWorld.id);
        if (deleted !== null) {
          throw new Error('World deletion failed');
        }

        statusEl.textContent = '‚úÖ All world operations successful';
        statusEl.className = 'status success';
        resultsEl.innerHTML = `
                    <div class="status success">
                        <strong>World CRUD Test Results:</strong><br>
                        ‚úÖ Create: Success<br>
                        ‚úÖ Read: Success<br>
                        ‚úÖ Update: Success<br>
                        ‚úÖ List: Success<br>
                        ‚úÖ Delete: Success
                    </div>
                `;
        log('All world operations completed successfully', 'success');

      } catch (error) {
        statusEl.textContent = `‚ùå World operations failed: ${error.message}`;
        statusEl.className = 'status error';
        resultsEl.innerHTML = `<div class="status error">Error: ${error.message}</div>`;
        log(`World operations failed: ${error.message}`, 'error');
      }
    };

    // Test bulk operations
    window.testBulkOperations = async () => {
      try {
        log('Testing bulk operations...', 'info');

        // Create multiple worlds
        const worlds = [];
        for (let i = 1; i <= 5; i++) {
          const world = {
            id: `bulk-world-${i}`,
            name: `Bulk World ${i}`,
            turnLimit: i * 10,
            agents: [],
            created: Date.now()
          };
          worlds.push(world);
          await storage.setItem(STORES.worlds, world.id, world);
        }

        // List all worlds
        const keys = await storage.listKeys(STORES.worlds);
        log(`Created ${worlds.length} worlds, found ${keys.length} total keys`, 'info');

        // Clear all test worlds
        for (const world of worlds) {
          await storage.removeItem(STORES.worlds, world.id);
        }

        log('Bulk operations completed successfully', 'success');
      } catch (error) {
        log(`Bulk operations failed: ${error.message}`, 'error');
      }
    };

    // Clear all worlds
    window.clearAllWorlds = async () => {
      try {
        await storage.clearStore(STORES.worlds);
        log('All worlds cleared successfully', 'success');
        await getStorageStats();
      } catch (error) {
        log(`Failed to clear worlds: ${error.message}`, 'error');
      }
    };

    // Test fallback chain
    window.testFallbackChain = async () => {
      const statusEl = document.getElementById('fallback-status');
      const resultsEl = document.getElementById('fallback-results');

      try {
        statusEl.textContent = 'Testing fallback chain...';
        statusEl.className = 'status info';

        const currentLevel = storage.getStorageLevel();
        log(`Current storage level: ${currentLevel}`, 'info');

        // Test data persistence across different scenarios
        const testData = { test: 'fallback-data', timestamp: Date.now() };
        await storage.setItem(STORES.settings, 'fallback-test', testData);

        const retrieved = await storage.getItem(STORES.settings, 'fallback-test');
        if (JSON.stringify(retrieved) !== JSON.stringify(testData)) {
          throw new Error('Fallback data consistency failed');
        }

        statusEl.textContent = '‚úÖ Fallback chain working correctly';
        statusEl.className = 'status success';
        resultsEl.innerHTML = `
                    <div class="status success">
                        Current Level: ${currentLevel}<br>
                        Data Consistency: ‚úÖ Verified
                    </div>
                `;
        log('Fallback chain test completed successfully', 'success');

      } catch (error) {
        statusEl.textContent = `‚ùå Fallback test failed: ${error.message}`;
        statusEl.className = 'status error';
        resultsEl.innerHTML = `<div class="status error">Error: ${error.message}</div>`;
        log(`Fallback test failed: ${error.message}`, 'error');
      }
    };

    // Test performance
    window.testPerformance = async () => {
      const statusEl = document.getElementById('perf-status');
      const resultsEl = document.getElementById('perf-results');

      try {
        statusEl.textContent = 'Running performance test...';
        statusEl.className = 'status info';

        const iterations = 100;
        const testData = { data: 'x'.repeat(1000) }; // 1KB of data

        // Test write performance
        const writeStart = performance.now();
        for (let i = 0; i < iterations; i++) {
          await storage.setItem(STORES.settings, `perf-test-${i}`, testData);
        }
        const writeTime = performance.now() - writeStart;

        // Test read performance
        const readStart = performance.now();
        for (let i = 0; i < iterations; i++) {
          await storage.getItem(STORES.settings, `perf-test-${i}`);
        }
        const readTime = performance.now() - readStart;

        // Cleanup
        for (let i = 0; i < iterations; i++) {
          await storage.removeItem(STORES.settings, `perf-test-${i}`);
        }

        statusEl.textContent = '‚úÖ Performance test completed';
        statusEl.className = 'status success';
        resultsEl.innerHTML = `
                    <div class="status success">
                        <strong>Performance Results (${iterations} operations):</strong><br>
                        Write: ${writeTime.toFixed(2)}ms (${(writeTime / iterations).toFixed(2)}ms/op)<br>
                        Read: ${readTime.toFixed(2)}ms (${(readTime / iterations).toFixed(2)}ms/op)<br>
                        Storage Level: ${storage.getStorageLevel()}
                    </div>
                `;
        log(`Performance test: Write=${writeTime.toFixed(2)}ms, Read=${readTime.toFixed(2)}ms`, 'success');

      } catch (error) {
        statusEl.textContent = `‚ùå Performance test failed: ${error.message}`;
        statusEl.className = 'status error';
        resultsEl.innerHTML = `<div class="status error">Error: ${error.message}</div>`;
        log(`Performance test failed: ${error.message}`, 'error');
      }
    };

    // Simulate storage errors
    window.simulateErrors = async () => {
      log('Simulating storage error scenarios...', 'info');
      // This would require more complex mocking to test properly
      log('Error simulation requires development environment setup', 'info');
    };

    // Test large data storage
    window.testLargeData = async () => {
      try {
        log('Testing large data storage...', 'info');

        const largeData = {
          id: 'large-test',
          data: 'x'.repeat(100000), // 100KB
          timestamp: Date.now()
        };

        const start = performance.now();
        await storage.setItem(STORES.settings, 'large-test', largeData);
        const stored = await storage.getItem(STORES.settings, 'large-test');
        const time = performance.now() - start;

        if (stored.data.length !== largeData.data.length) {
          throw new Error('Large data integrity check failed');
        }

        await storage.removeItem(STORES.settings, 'large-test');
        log(`Large data test successful: ${time.toFixed(2)}ms for 100KB`, 'success');

      } catch (error) {
        log(`Large data test failed: ${error.message}`, 'error');
      }
    };

    // Dump debug information
    window.dumpDebugInfo = async () => {
      try {
        const stats = await storage.getStats();
        const info = {
          userAgent: navigator.userAgent,
          storageLevel: storage.getStorageLevel(),
          indexedDBSupported: 'indexedDB' in window,
          localStorageSupported: 'localStorage' in window,
          stats: stats,
          timestamp: new Date().toISOString()
        };

        log('=== DEBUG INFO ===', 'info');
        log(JSON.stringify(info, null, 2), 'info');
        log('==================', 'info');
      } catch (error) {
        log(`Failed to dump debug info: ${error.message}`, 'error');
      }
    };        // Clear logs
    window.clearLogs = () => {
      document.getElementById('debug-logs').textContent = '';
    };

    // Phase 3.2 Integration Tests
    window.runPhase32Tests = async () => {
      const statusEl = document.getElementById('integration-status');
      const resultsEl = document.getElementById('integration-results');

      try {
        statusEl.textContent = 'Running Phase 3.2 Integration Tests...';
        statusEl.className = 'status info';
        resultsEl.innerHTML = '<div class="status info">Test execution in progress...</div>';

        // Initialize storage first
        await storage.init();

        // Create and run integration tests
        const integrationTests = new window.StorageIntegrationTests(storage, STORES, STORAGE_LEVELS);
        await integrationTests.runAllTests();

        // Get results
        const results = window.testResults;
        const success = results.failed === 0;

        statusEl.textContent = success ?
          '‚úÖ Phase 3.2 Integration Tests Completed Successfully' :
          '‚ùå Phase 3.2 Integration Tests Failed';
        statusEl.className = success ? 'status success' : 'status error';

        resultsEl.innerHTML = `
                    <div class="status ${success ? 'success' : 'error'}">
                        <h4>Phase 3.2 Test Results</h4>
                        <p><strong>Total Tests:</strong> ${results.total}</p>
                        <p><strong>Passed:</strong> ${results.passed} (${((results.passed / results.total) * 100).toFixed(1)}%)</p>
                        <p><strong>Failed:</strong> ${results.failed} (${((results.failed / results.total) * 100).toFixed(1)}%)</p>
                        ${results.failed > 0 ? `
                            <h5>Failed Tests:</h5>
                            <ul>
                                ${results.results.filter(r => !r.status).map(r =>
          `<li>${r.name}: ${r.details}</li>`
        ).join('')}
                            </ul>
                        ` : ''}
                        <p><strong>Phase 3.2 Status:</strong> ${success ? '‚úÖ READY FOR PHASE 4' : '‚ùå REQUIRES FIXES'}</p>
                    </div>
                `;

        log(`Phase 3.2 Integration Tests completed: ${results.passed}/${results.total} passed`, success ? 'success' : 'error');

      } catch (error) {
        statusEl.textContent = `‚ùå Integration test execution failed: ${error.message}`;
        statusEl.className = 'status error';
        resultsEl.innerHTML = `<div class="status error">Error: ${error.message}</div>`;
        log(`Phase 3.2 integration test failed: ${error.message}`, 'error');
      }
    };

    // Generate integration test report
    window.generateIntegrationReport = () => {
      if (!window.testResults || window.testResults.total === 0) {
        log('No test results available. Run Phase 3.2 tests first.', 'error');
        return;
      }

      const results = window.testResults;
      const report = {
        phase: '3.2 Browser Storage Integration',
        timestamp: new Date().toISOString(),
        browser: navigator.userAgent,
        storageLevel: storage.getStorageLevel(),
        summary: {
          total: results.total,
          passed: results.passed,
          failed: results.failed,
          successRate: ((results.passed / results.total) * 100).toFixed(1) + '%'
        },
        results: results.results
      };

      log('=== PHASE 3.2 INTEGRATION REPORT ===', 'info');
      log(JSON.stringify(report, null, 2), 'info');
      log('====================================', 'info');
    };

    // Clear logs
    window.clearLogs = () => {
      document.getElementById('debug-logs').textContent = '';
    };

    // Auto-initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      log('Storage test page loaded', 'info');
    });
  </script>
</body>

</html>